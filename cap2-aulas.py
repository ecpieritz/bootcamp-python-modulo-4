# -*- coding: utf-8 -*-
"""concorrencia.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Cig_ppjO__z3oLCoVlpj1CFD4ZUbmp4S
"""

#concorrência - Códigos adaptados de [FORBES, Elliot. Learning Concurrency in Python: Build highly efficient, robust, and concurrent applications. 2017.]

#identificando a quantidade de núcleos disponíveis para o sistema
import multiprocessing
multiprocessing.cpu_count() #conta a quantidade de núcleos disponíveis no sistema

#processamento sequencial
import threading  #módulo para a construção de threads
import urllib.request  #módulo para a requisição de url
import time  #módulo para tratar tempo

#função criada para a realização do download das imagens
def downloadImagens(imagePath, fileName):
  print("Realizando o download .... ", imagePath)
  urllib.request.urlretrieve(imagePath, fileName)  #realiza a requisição para a página da web


t0 = time.time() #armazena o tempo inicial de execução
for i in range(10):
  imageName = "imagens/image-" + str(i) + ".jpg"  #coloca o nome em cada uma das imagens baixadas
  downloadImagens("http://lorempixel.com/400/200/sports", imageName)  #aplica o download da imagem
  
t1 = time.time() #tempo final após a execução
totalTime = t1 - t0  #diferença de tempo entre o valor inical de execução e o final
print("Tempo toal de execução {}".format(totalTime))

#exedcução do download de imagens via multiplas threads
import threading
import urllib.request
import time

def downloadImagens(imagePath, fileName):
  print("Realizando o download .... ", imagePath)
  urllib.request.urlretrieve(imagePath, fileName)
  print("Download Finalizado")

def executeThread(i): 
  imageName = "imagens_thread/image-" + str(i) + ".jpg"
  downloadImagens("http://lorempixel.com/400/200/sports", imageName)


t0 = time.time()

threads = [] #lista vazia que vai conter todas as threads criadas

#cria das 10 threads, cada uma delas será responsável por realizar o download
for i in range(10):
  thread = threading.Thread(target=executeThread, args=(i,))
  threads.append(thread)
  thread.start()
  
#garante que as execuções foram finalizadas
for i in threads:
  i.join()

#calcula o tempo de execução
t1 = time.time()
totalTime = t1 - t0
print("Tempo total de execução {}".format(totalTime))

"""**Compartilhamento de tempo**"""

import threading  #módulo para a construção de multithreads
import time  #módulo para a medição de tempo
import random  #módulo para geração de números randomicos

counter = 10   #contador inicial

#função que adiciona um número para o contador
def tarefaA():
  global counter  #variável global 
  while counter < 30:
    counter += 1  #incrementa o contador
    print("A tarefaA incrementou o contador para {}".format(counter))
    sleepTime = random.randint(0,3) #escolhe, randomicamente, um valor entre 0 e 3
    time.sleep(sleepTime) #coloca a tread para dormir

#função que retira um número do contador
def tarefaB():
  global counter #variável global
  while counter > -30:
    counter -= 1  #decrementa o contador
    print("A tarefaB decrementou o contador para {}".format(counter))
    sleepTime = random.randint(0,3) #escolhe, randomicamente, um valor entre 0 e 3
    time.sleep(sleepTime) #coloca a tread para dormir


t0 = time.time()
thread1 = threading.Thread(target=tarefaA) #instancia um objeto da classe Thread para executar
                                           #a tarefaA
thread2 = threading.Thread(target=tarefaB) #instancia um objeto da classe Thread para executar
                                           #a tarefaB

thread1.start() #inicia a tread1
thread2.start() #inicia thread2

thread1.join()  #ceritifica o fim da execução
thread2.join() #certifica do fim da execução

t1 = time.time()

print("Tempo total de execução {}".format(t1-t0))

"""**Estados de execução de uma Thread**"""

import threading
import time

# função que, simplesmente, realiza o print de uma mensagem de execução e 
def threadWorker():
  # Neste ponto é onde ocorre a mudança do 'Runnable' para o 'Running'

  print("A thread entrou no estado 'Running'")

  # quando chamamos a função time.sleep() a 
  #thread entra para o estado de not-running
  print('A thread entrou no estado "Non-Running"')
  time.sleep(10)
  # quando a tarefa é finalizada, a thread é terminada 
  print("Execução da thread foi finalizada")
  #garbage collector



# neste momento a threada ainda "não possui estados"
#não existe alocação de recursos
print("Thread Criada")
myThread = threading.Thread(target=threadWorker)

#quando é chamado o método myThread.start(), python realiza a 
#alocação de recursos e, posteriormente, passa para o estado de
# "Start" para o "Runnable", mas sem entrar em execução.
print("Thread no estado 'Runnable'")
myThread.start()

#quando o metodo join é chamado, a thread passa para o estado
# "terminated"
myThread.join()
print("A thread está no estado de 'Terminated'")

"""**Outro exemplo de execução de uma Thread**"""

import threading
import time
import random

#função que recebe um número e cira uma thread
def executeThread(i):
  print("Thread {} incializada \n".format(i))
  sleepTime = random.randint(1,10)
  time.sleep(sleepTime)
  print("Thread {} finalizou a execução".format(i))

for i in range(10):
  thread = threading.Thread(target=executeThread, args=(i,))
  thread.start()

  print("Número de threads ativas:" , threading.enumerate())

"""**Herança com Threads**"""

from threading import Thread

#define a classe como filha da classe Thread
class MinhaClasseThread(Thread):
  def __init__(self):
    print("Olá, construtor thread!!")
    Thread.__init__(self)

  #define a função run() que é chamada quando thread.start()
  def run(self):
    print("\nThread em execução.")

#instanciando um objeto da classe criada
minhaThread=MinhaClasseThread()
print("Objeto criado")
minhaThread.start()
print("Thread inicalizada")
minhaThread.join()
print("Thread finalizada")

"""**Multiplas Threads**"""

import threading
 
class minhaThread (threading.Thread):
    def __init__(self, threadID, nome, contador):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.nome = nome
        self.contador = contador
    def run(self):
        print("Iniciando thread %s com %d processos" %(self.name,self.contador))
        processo(self.nome, self.contador)
        print("Finalizando " + self.nome)
 
def processo(nome, contador):
    while contador:
        print( "Thread %s fazendo o processo %d" % (nome, contador))
        contador -= 1
 
# Criando as threads
thread1 = minhaThread(1, "Alice", 8)
thread2 = minhaThread(2, "Bob", 8)
 
# Comecando novas Threads
thread1.start()
thread2.start()
 
threads = []
threads.append(thread1)
threads.append(thread2)
 
for t in threads:
    t.join()
 
print("Saindo da main")

"""**Contando Threads ativas**"""

import threading
import time
import random


def minhaThread(i):
  print("Thread {}: inicializada".format(i))
  time.sleep(random.randint(1,5))
  print("\nThread {}: finalizada".format(i))

for i in range(random.randint(2,50)):
  thread=threading.Thread(target=minhaThread,args=(i,))
  thread.start()
time.sleep(4)
print("Total de Threads ativas: {}".format(threading.active_count()))

"""**Em qual thread estamos?**"""

import threading
import time

def threadTarget():
  print("Thread atual: {}".format(threading.current_thread()))

threads = []

for i in range(10):
  thread = threading.Thread(target=threadTarget)
  thread.start()
  threads.append(thread)

for thread in threads:
  thread.join()

"""**Main Thread**"""

import threading
import time

def myChildThread():
  print("Thread Filha inicializada ----")
  time.sleep(5)
  print("Thread Atual ----------")
  print(threading.current_thread())
  print("-------------------------")
  print("Main Thread -------------")
  print(threading.main_thread())
  print("-------------------------")
  print("Thread Filha Finalizada")


child = threading.Thread(target=myChildThread)
child.start()
child.join()

"""**Identificando as Threads**"""

import threading
import time


def myThread():
  print("Thread {} inicializada".format(threading.currentThread().getName()))
  time.sleep(10)
  print("Thread {} finalizada".format(threading.currentThread().getName()))

for i in range(4):
  threadName = "Thread-" + str(i)
  thread = threading.Thread(name=threadName, target=myThread)
  thread.start()

print("{}".format(threading.enumerate()))

"""**Deadlock**"""

import threading
import time
import random

class Filosofos(threading.Thread):

  def __init__(self, name, leftFork, rightFork):
    print("{} sentou na mesa".format(name))
    threading.Thread.__init__(self, name=name)
    self.leftFork = leftFork
    self.rightFork = rightFork

  def run(self):
    print("{} começou a pensar".format(threading.currentThread().getName()))
    while True:
      time.sleep(random.randint(1,5))
      print("{} parou de pensar".format(threading.currentThread().getName()))
      self.leftFork.acquire()
      time.sleep(random.randint(1,5))
      try:
        print("{} pegou o garfo da esquerda.".format(threading.currentThread().getName()))

        self.rightFork.acquire()
        try:
          print("{} pegou os dois garfos e começou a comer".format(threading.currentThread().getName()))
        finally:
          self.rightFork.release()   
          print("{} soltou o garfo da direita".format(threading.currentThread().getName()))
      finally:
        self.leftFork.release()
        print("{} soltou o garfo da esquerda".format(threading.currentThread().getName()))

fork1 = threading.RLock()
fork2 = threading.RLock()
fork3 = threading.RLock()
fork4 = threading.RLock()
fork5 = threading.RLock()

philosopher1 = Filosofos("Kant", fork1, fork2)
philosopher2 = Filosofos("Aristotle", fork2, fork3)
philosopher3 = Filosofos("Spinoza", fork3, fork4)
philosopher4 = Filosofos("Marx", fork4, fork5)
philosopher5 = Filosofos("Russell", fork5, fork1)

philosopher1.start()
philosopher2.start()
philosopher3.start()
philosopher4.start()
philosopher5.start()

philosopher1.join()
philosopher2.join()
philosopher3.join()
philosopher4.join()
philosopher5.join()

"""**Semáforos**"""

import threading
import time
import random

class TicketSeller(threading.Thread):
  ticketsSold = 0

  def __init__(self, semaphore):
    threading.Thread.__init__(self);
    self.sem = semaphore
    print("Venda de ingressos inicializada")

  def run(self):
    global ticketsAvailable
    running = True
    while running:
      self.randomDelay()
      
      self.sem.acquire()
      if(ticketsAvailable <= 0):
        running = False
      else:
        self.ticketsSold = self.ticketsSold + 1
        ticketsAvailable = ticketsAvailable - 1
        print("{} acabou de vender 1 ({} restantes)".format(self.getName(), ticketsAvailable))
      self.sem.release()
    print("Venda de ingresso {} Ingressos vendidos no total {}".format(self.getName(), self.ticketsSold))

  def randomDelay(self):
    time.sleep(random.randint(0,4)/4)


# definição do nosso semáforo
semaphore = threading.Semaphore()
# Número de ingressos disponíveis
ticketsAvailable = 200

# os nossos vendedores
sellers = []
for i in range(4):
  seller = TicketSeller(semaphore)
  seller.start()
  sellers.append(seller)

# joining all our sellers
for seller in sellers:
  seller.join()

"""**Queue em Python**"""

#código adaptado de http://www.learn4master.com/algorithms/python-queue-for-multithreading
#  put(), get(), join() e task_done().
import threading
import time
from queue import Queue 

def consumidor(q):
    while(True):
        name = threading.currentThread().getName()
        print("Thread: {0} deseja obter um item da queue[tamanho atual = {1}] na data = {2} \n".format(name, q.qsize(), time.strftime('%H:%M:%S')))
        item = q.get();
        time.sleep(3)  # demora 3 segundos para adicionar um item
        print("Thread: {0} terminou de processar o item da queue[tamanho atual = {1}] na data = {2} \n".format(name, q.qsize(), time.strftime('%H:%M:%S')))
        q.task_done()


def produtor(q):
    # a thread principal vai adicionar itens para a queue

    for i in range(10):
        name = threading.currentThread().getName()
        print("Thread: {0} começou a adicionar um item na queue[tamanho atual = {1}] na data = {2} \n".format(name, q.qsize(), time.strftime('%H:%M:%S')))
        item = "item-" + str(i)
        q.put(item)
        print("Thread: {0} adicionou um item na queue[tamanho atual = {1}] na data = {2} \n".format(name, q.qsize(), time.strftime('%H:%M:%S')))

    q.join()

if __name__ == '__main__':
    q = Queue(maxsize = 3)

    threads_num = 3  # criação de 3 threads consumidoras
    for i in range(threads_num):
        t = threading.Thread(name = "ThreadConsumidora-"+str(i), target=consumidor, args=(q,))
        t.start()

    # criação de uma thread produtora
    t = threading.Thread(name = "ThreadProdutora", target=produtor, args=(q,))
    t.start()

    q.join()